% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/apply.R
\docType{methods}
\name{r.apply,scidbst}
\alias{r.apply}
\alias{r.apply,scidb}
\alias{r.apply,scidbst}
\alias{r_exec}
\title{Apply custom R functions on scidbst array chunks}
\usage{
\S4method{r.apply}{scidbst,`function`}(x, f, array, packages,
  parallel = FALSE, cores = 1, aggregates, output, logfile, dim, dim.spec,
  method = "rexec", ...)

\S4method{r.apply}{scidb,`function`}(x, f, array, packages, parallel = FALSE,
  cores = 1, aggregates = c(), output, logfile, ...)
}
\arguments{
\item{x}{scidbst array or scidb array}

\item{f}{r function of form \code{function(x) { ... }} expecting parameter x, which is a subset of the incoming data based on the aggregate statement}

\item{array}{string with the name of the output array}

\item{packages}{a vector of string of the packages required for the function f}

\item{parallel}{(optional) boolean whether or not the chunk is processed in parallel at an instance}

\item{cores}{(optional) if using parallel this specifies the number of cores to use at an instance}

\item{aggregates}{(optional) a vector of attribute names to group by}

\item{output}{a named list of output attributes and its scidb type (if using rexec method it will be 'double' regardless)}

\item{logfile}{(optional) the file path used to log during the processing if required}

\item{dim}{(optional) a named list with attribute name = output attribute name e.g. \code{list(dimy="y",dimx="x")}}

\item{dim.spec}{(optional) a named list with the dimension specification using the output dimension name as a identifier and a named numeric vector with min, max, overlap and chunk to specify the dimensionality}

\item{method}{The method to use, either "rexec" or "stream"; not utilized currently}

\item{...}{see Details}
}
\value{
scidbst array or scidb array depending on the input
}
\description{
This function applies a custom r function on each individual scidbst array chunk using the r_exec interface with
SciDB.
}
\details{
The script that is created during this function will handle the installation of required R-packages on
each of the instances. Then it combines the incoming attribute vectors to a data.frame object, which is passed
on to the '\code{\link[plyr]{ddply}}' function of the package 'plyr'. Depending on the stated aggregates parameter
the function 'f' is applied on that grouped sub data.frame object (parameter x of function f). Using the output
list the array will be projected on to the selected attributes. When specifying 'dim' and 'dim.spec' the stated
columns of the data.frame will be used as dimension in a perceeding redimension call.

The \code{...} operator can contain the parameter \code{eval}, which is set to TRUE as default.
Also \code{...} can contain a developer parameter called \code{result} with the allowed values "afl" and
"rscript". \code{r.apply} then returns the submitted R-Script or the resulting AFL query. To
prevent the function from being executed use result in combination with "eval=FALSE".

The following variable names are reserved if the spatial and temporal references exists and are transferred to ddply
function:
\describe{
 \item{\code{affine}}{a 2x3 matrix for spatial coordinate transformation}
 \item{\code{crs}}{a CRS object stating the used coordinate reference system}
 \item{\code{extent}}{a extent object stating the spatial extent}
 \item{\code{tmin} / \code{tmax}}{POSIXlt objects stating the minimum and maximum temporal boundary}
 \item{\code{t0}}{POSIXlt object marking the datum (time at value 0)}
 \item{\code{tunit}}{character describing the temporal measurement unit}
 \item{\code{tres}}{a number describing the temporal resolution}
}
}
\note{
The function that can be stated has the following description "function(x,...) {}". The x parameter is a
data.frame of the attributes stored in one chunk. In most cases you are advised to transform the array to have the
dimension values as attributes if you need those to perform calculations. The function will be passed on to the \link[plyr]{ddply}
function.

parameter option "stream" for 'method' currently not supported.
}
\examples{
\dontrun{
 input.arr = scidbst("some_scidbst_array")

 # make sure to have the dimensions as attributes if you plan to use them in calculations
 input.arr = transform(input.arr, dimx="double(x)",dimy="double(y)", dimt="double(t)")
 f <- function(x,...) {
     # parse the parameter passed as ... into the function and assign them to the functions
     # environment
     dot.input = list(...)
     i <- 1
     lapply(dot.input, function(x,y) {
         assign(x=y[i],value=x,envir=parent.env(environment()))
         i <<- i+1
         x
       },
       names(dot.input)
     )
     rm(i)

     if (is.null(x)) {
       return(c(nt=0,var=0,median=0,mean=0))
     }
     t = x$dimt
     n = x$val
     return(c(nt=length(t),var=var(n),median=median(n),mean=mean(n)))
   }
 rexec.arr = r.apply(x=input.arr,
     f=f,
     array="output_array",
     parallel=FALSE,
     cores=1,
     aggregates=c("dimy","dimx"),
     output=list(dimy="double",dimx="double",nt="double",var="double",median="double",mean="double"),
     dim=list(dimy="y",dimx="x"),
     dim.spec=list(y=c(min=0,max=99,chunk=20,overlap=0),x=c(min=0,max=99,chunk=20,overlap=0)),
     logfile="/tmp/logfile.log")
}
}

